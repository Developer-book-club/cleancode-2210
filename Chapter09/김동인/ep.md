# Overview

---

- **TDD(Test Driven Development)**라는 개념은 많은 성장을 했다.
    - 이전에는 단위 테스트란 메서드를 공들여 구현한 후 프로그램이 ‘돌아간다’ 사실만 확인하는 일회성 코드에 불가했다.
- 테스트를 추가하려고 급하게 서두르는 와중에 많은 개발자들이 제대로 된 테스트 케이스를 작성해야 하는 사실을 놓치고 있다.

# TDD 법칙 세 가지

- TDD는 실제 코드를 짜기 전에 단위 테스트부터 짜라고 요구한다.

**TDD 법칙**

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행시 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

- 위의 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다.
- 테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 몇 초 전에 나온다.
- 실제 코드를 전부 테스트하는 테스트 케이스가 나온다.
- 하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발할 수 있다.

# 깨끗한 테스트 코드 유지하기

- 테스트 코드에 실제 코드와 동일한 품질 기준을 적용하지 않아야 할까?
    - 실제 코드가 진화하면 테스트 코드도 변해야 한다.
    - 테스트 코드가 지저분할수록 변경하기가 어려워진다.
- 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 십상이다.
    - 실제 코드를 변경했을 때 기존 테스트 케이스가 실패하기 시작한다면 테스트 코드는 부담이 된다.
    - 새 버전을 출시할 때 테스트 케이스를 유지하고 보수하는 비용도 늘어난다.
    - 테스트 코드는 개발자 사이에서 큰 불만이 된다.
    - 테스트 슈트를 폐기해야 하는 상황에 처한다.
- 테스트 슈트가 없으면 개발자가 수정한 코드가 제대로 도는지 확인할 방법이 없다.
    - 시스템이 수정해도 안전한지 사실을 검증하지 못한다.
    - 결함율이 높아지기 시작한다.
    - 의도하지 않은 결함 수가 많아지면 개발자는 변경을 주저한다.
- 테스트에 쏟아 부은 노력은 허사일 수 있다. 하지만 그 실패를 초래한 원인은 테스트 코드를 막 짜도 좋다고 허용한 결정이었다.
    - 테스트 코드를 깨끗하게 짰다면 테스트에 쏟아 부은 노력은 허사로 돌아가지 않는다.
- **테스트 코드는 실제 코드 못지 않게 중요하다.**

## 테스트는 유연성, 유지보수성, 재사용성을 제공한다

- 테스트 코드를 깨끗하게 유지하지 않으면 결국은 잃어버린다.
- 코드에 **유연성**, **유지보수성**, **재사용성**을 제공하는 버팀목이 바로 테스트다.
    - 테스트 케이스가 있으면 변경이 두렵지 않다!
        - 테스트 케이스가 없다면 모든 변경은 잠정적인 버그이다.
        - 아키텍처가 아무리 유연하더라도 테스트 케이스가 없으면 개발자는 변경을 주저한다. 버그가 숨어들까봐 두렵기 때문이다.
- 테스트 케이스가 있다면 공포는 사실상 사라진다.
    - 테스트 커버리지가 높을수록 공부는 줄어든다.
- 자동화된 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다.
- 테스트 케이스가 있으면 변경이 쉬워지기 때문이다.
    - 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지면 코드 구조를 개선하는 능력도 떨어진다.
    - 테스트 코드를 잃어버리면 실제 코드도 망가진다.

# 깨끗한 테스트 코드

- 깨끗한 테스트 코드는 **가독성**이 중요하다.
    - 실제 코드보다도 더 중요할 수있다.
- 명료성, 단순성, 풍부한 표현력이 필요하다.

<aside>
💡 **BUILD-OPERATE-CHECK 패턴**

승인 테스트에서 반복적으로 나타납니다. 주어진 요구 사항을 완전히 테스트하려면 단일 페이지에서 여러 테이블을 사용해야 합니다. 이러한 테이블은 자연스럽게 세 가지 범주로 나뉩니다.

1. **Build**: 테스트 데이터 를 빌드 할 하나 이상의 테이블 입니다. **이러한 테이블은 일반적으로 valid()** 함수 에 해당 하는를 기반으로 합니다. 테이블의 행은 데이터를 로드 및 저장하고 **valid()** 함수는 데이터가 유효하고 올바르게 저장되었는지 여부를 나타내는 boolean을 반환합니다.
2. **Operate**: 데이터에 대해 연산을 수행할 테이블입니다.[이 테이블은 일반적으로 ColumnFixture](http://fitnesse.org/FitNesse.FullReferenceGuide.UserGuide.WritingAcceptanceTests.FitFramework.ColumnFixture)를 기반으로 하며 항상 valid()함수에 해당합니다. 열은 작업의 인수를 지정하고 valid() 함수는 작업을 수행하고 성공을 나타내는 부울을 반환합니다.
3. **확인**: 작업의 유효성을 검사할 하나 이상의 테이블입니다. 이러한 설비는 [ColumnFixture 또는](http://fitnesse.org/FitNesse.FullReferenceGuide.UserGuide.WritingAcceptanceTests.FitFramework.ColumnFixture) [RowFixture](http://fitnesse.org/FitNesse.FullReferenceGuide.UserGuide.WritingAcceptanceTests.FitFramework.RowFixture) 또는 스타일일 수 있습니다 . 이 표에서 실제 승인 테스트가 수행됩니다. 다른 두 테이블은 확인 작업에 대한 조건을 설정합니다.
</aside>

[FitNesse.FullReferenceGuide.UserGuide.WritingAcceptanceTests.AcceptanceTestPatterns.BuildOperateCheck](http://fitnesse.org/FitNesse.FullReferenceGuide.UserGuide.WritingAcceptanceTests.AcceptanceTestPatterns.BuildOperateCheck)

- **BUILD-OPERATE-CHECK 패턴**은 이와 같은 테스트 구조에 적합하다. 각 테스트는 세 부분으로 나눠진다.
    1. 테스트 자료를 만든다
    2. 테스트 자료를 조작한다
    3. 조작한 결과가 올바른지 화깅ㄴ한다.
- 테스트 코드는 잡다한 코드를 없애고 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용한다.
- 코드를 읽는 사람은 온갖 잡다하고 세세한 코드에 주늑들 필요없이 코드가 수행하는 기능을 재빨리 이해할 수 있다.

## 도메인에 특화된 테스트 언어

```java
public void testGetPageHierarchyAsXml() throws Exception {
  makePages("PageOne", "PageOne.ChildOne", "PageTwo");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>");
}

public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception {
  WikiPage page = makePage("PageOne");
  makePages("PageOne.ChildOne", "PageTwo");

  addLinkTo(page, "PageTwo", "SymPage");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>");
  assertResponseDoesNotContain("SymPage");
}

public void testGetDataAsXml() throws Exception {
  makePageWithContent("TestPageOne", "test page");

  submitRequest("TestPageOne", "type:data");

  assertResponseIsXML();
  assertResponseContains("test page", "<Test");
}
```

- 도메인에 특화된 언어(DSL)로 테스트 코드를 구현하는 기법을 보여준다.
- 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현한 후 그 함수와 유틸리티를 사용하므로 테스트 코드를 짜기도 읽기도 쉬워진다.
- 이렇게 구현한 함수와 유틸리티는 테스트 코드에서 사용하는 특수 API가 된다. 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 **테스트 언어**다.

## 이중 표준

- 테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다.
    - 단순하고 간결하고 표현력이 풍부해야 하지만 실제 코드만큼 효율적인 필요는 없다.
- 프로덕션 환경과 테스트 환경은 다르게 적용해야 한다.
    - 테스트 관련된 코드는 실제 환경에서 되지 않더라도 테스트환경에서만 가능하면 된다. 즉, 테스트 관련 코드는 가독성에만 집중하면 된다. 메모리나 CPU 효율 따위는 테스트 코드의 깨끗함과 무관하다.
    

# 테스트 당 assert 하나

- JUnitd으로 테스트 코드를 짤 때는 함수마다 assert 문을 단 하나만 사용해야한다는 의견이 있다.
    - 가혹하지만 확실한 장점은 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
- 두 개의 assert문이 있다면 테스트를 두 개로 쪼개서 각각 수행하는 것을 고려하자.
- given-when-then 관례를 사용하면 테스트 코드를 읽기가 쉬워진다.
- 하지만 테스트를 분리하면 중복되는 코드가 많아진다.
    - Template Method 패턴을 쓰면 중복을 제거할 수 있다.
        - given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 된다.
    - 독자적으로 테스트 클래스를 만들어 `@Before` 함수에 given/when 부분을 넣고 `@Test` 함수에 then 부분을 넣어도 된다.

## 테스트 당 개념 하나

- 테스트 함수마다 한 개념만 테스트하라
    - 잡다한 개념을 연속으로 테스트하는 긴 함수는 피한다.
    - 독자적인 개념 세 개를 테스트하므로 독자적인 테스트 세 개로 쪼개야 마땅하다.
- 가장 좋은 규칙은 “개념 당 assert 문 수를 최소로 줄여라”와 “테스트 함수 하나는 개념 하나만 테스트하라”이다.

# F.I.R.S.T

- 깨끗한 테스트의 다섯가지 규칙

## Fast(빠르게)

- 테스트는 빨라야 한다.
- 테스트가 느리면 자주 돌릴 엄두를 못 낸다.
- 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다.
- 코드를 마음 껏 정리하지도 못한다.
- 코드 품질이 망가지기 시작한다.

## Independent(독립적으로)

- 각 테스트는 서로 의존하면 안된다.
- 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다.
- 각 테스트는 독립적으로 어떤 순서로 실행되도 괜찮아야 한다.
- 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.

# Repeatable(반복가능하게)

- 테스트는 어떤 환경에도 반복 가능해야 한다.
- 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패할 이유를 둘러댈 변명이 생긴다.
- 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.

# Self-Validating(자가검증하는)

- 테스트는 boolean 값으로 결과를 내야한다. 성공 아니면 실패다.
- 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안된다.
- 통과 여부를 보려고 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안된다.
- 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 되낟.

# Timely(적시에)

- 테스트는 적시에 작성해야 한다.
- 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.
- 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.
- 어떤 실제 코드는 테스트하기 너무 어렵거나 불가능하도록 설계하고 있을지 모른다.

# 결론

- TDD의 겉핥기 수준이다.
- 깨끗한 테스트 코드라는 책 한 권을 할애해도 모자랄 주제다. 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다.
- 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다.
- 테스트 API를 구현해 도메인 특화 언어(Domaiin Specific Langugage, DSL)를 만들자.
    - 테스트 코드를 짜기 쉬워진다.
- 테스트 코드가 방치되어 망가지면 실제 코드도 망가진다. 테스트 코드를 깨끗하게 유지하자.
