# Overview

---

- 오류 처리는 프로그램에 반드시 필요한 요소 중 하나일 뿐이다.
- 잘못될 가능성은 늘 존재한다. 잘못되었을 때 바로 잡을 책임은 개발자한테 있다.
- 깨끗한 코드와 오류처리는 확실히 연관성이 있다. 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기는 어렵다.
- 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.

# 오류 코드보다 예외를 사용하라

- 얼마 전까만 해도 예외를 지원하지 않는 프로그래밍 언어가 많았다.
- 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 깔끔해진다. 논리와 오류 처리 코드가 뒤섞이지 않기 때문이다.

# Try-Catch-Finally 문부터 작성하라

- 예외에서 프로그램 안에다 범위를 정의한다는 사실은 매우 흥미롭다.
- try-catch-finally 문에서 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다.
- 어떤 면에서 try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다. 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다.
- try-catch 구주로 범위를 정의하면 TDD를 사용해 필요한 나머지 논리를 추가할 수 있다.

# 미확인(uncheked) 예외를 사용하라

- 논쟁은 끝났다. 여러 해 동안 자바 개발자들은 checked exception의 장단점을 놓고 논쟁을 벌여왔다.
- 처음으로 자바가 공개되었을 때 checked exception을 멋진 아이디어로 생각했다.
- 하지만 지금은 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지 않다는 사실이 분명해졌다.
    - C#은 checked exception을 지원하지 않는다.
    - C++도 checked exception을 지원하지 않는다.
    - 파이썬과 루비도 checked exception을 지원하지 않는다.
- checked exception이 치르는 비용에 상응하는 이익을 제공하는지 철저히 따져봐야 한다.
    - OCP(Open Closed Principle)을 위반한다.
        - 메서드에서 checked exception을 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메서드 모두가 선언부에 해당 예외를 정의해야 한다.
            - 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다.
        - 모듈과 관련된 코드가 전혀 바뀌지 않았더라도 (선언부가 바뀌었으므로) 모듈을 다시 빌드한 다음에 배포해야 한다.
    - 대규모 시스템에서 호출이 일어나는 방식
        - 최상위 함수가 아래 함수를 호출한다. 아래 함수는 그 아래 함수를 호출한다. 단계를 내려갈수록 호출하는 함수 수는 늘어난다. 최하위 함수에서 checked exception을 추가하면 그 함수를 호출하는 함수에 모두 throws를 추가해야 한다.
        - throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.
    - 때로는 확인된 예외도 유용하다. 하지만 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다.

# 예외에 의미를 제공하라

- 예외를 던질 때는 전후 상황을 충분히 덧붙이다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다.
- 자바는 모든 예외에 호출 스택을 제공한다. 실패한 코드의 의도를 파악하려면 호출 스택만으로 부족하다.
- 오류 메시지에 정보를 담아 예외와 함께 던진다.
    - 실패한 연산 이름과 실패 유형도 언급한다.
    - 로깅 기능을 사용한다면 catch 블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.

# 호출자를 고려해 예외 클래스를 정의하라

- 오류를 분류하는 방법은 많다.
    - 오류가 발생하는 위치로 분류
    - 애플리케이션에서 오류를 정의할 때 개발자에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.
- 외부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다.
    - 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 테스트 하기도 쉬워진다.
    - 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다.
    - 예외 클래스가 하나만 있어도 충분한 코드가 많다. 하지만 예외 클래스에 포함된 정보로 오류를 구분하는 경우에 여러 예외 클래스를 사용한다.

# 정상 흐름을 정의하라

- 비즈니스 논리와 오류 처리가 잘 분리된 코드가 나와야 한다.
- 외부 API를 감싸 독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리한다.
- 대개는 멋진 처리 방식이지만 때로는 중단이 적합하지 않은 때도 있다.
- 특수 사례 패턴(Special Case Pattern)은 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다.
    - 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리한다.

# null을 반환하지 마라

- 오류를 유발하는 행위에 대한 이야기다.
- null을 반환하지 않아야 한다.
    - null을 반환하는 코드는 일거리 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.
- null을 반환해야 하는 상황에서 예외를 던지거나 특수 사례객체를 반환해야 한다.

# null을 전달하지 마라

- 메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다.
- 메서드로 null을 전달하는 코드는 최대한 피해야한다.
- 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다. 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 인수로 null이 넘어오면 코드에 문제가 있다.

# 결론

- 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
- 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하여 튼튼하고 꺠끗한 코드를 작성해야 한다.
