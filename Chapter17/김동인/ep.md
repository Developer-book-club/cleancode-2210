# Overview

---

- 마틴 파울러의 Refactoring 책에서는 다양한 ‘코드 냄새’를 거론한다.

> **휴리스틱**
(heuristics) 또는 발견법(發見法)이란 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나, 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편추론의 방법

# 주석

---

## C1: 부적절한 정보

- 다른 시스템에 저장할 정보는 주석으로 적절하지 못한다.
- 메타 정보만 주석으로 넣는다.
- 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다.

## C2: 쓸모 없는 주석

- 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없다.
- 주석은 빨리 낡는다.
    - 코드와 무관하게 혼자서 따로 놀 수 있다.
- 쓸모 없어질 주석은 달지 않는 편이 낫다.

## C3: 중복된 주석

- 코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석이다.

```json
i++; // i 증가
```

- 함수 시그니처(signature)만 달랑 기술하는 Javadoc도 문제다.

```java
/**
 * @param sellRequest
 * @return
 * @throws ManagedComponentException
 */
public SellResponse beginSellItem(SellRequest sellRequest) throws ManagedComponentException
```

## C4: 성의 없는 주석

- 작성할 가치있는 주석은 잘 작성할 가치도 있다.
- 단어를 신중하게 선택한다.
- 문법과 구두점을 올바로 사용한다. 주절대지 않는다. 당연한 소리를 반복하지 않는다. 간결하고 명료하게 작성한다.

## C5: 주석 처리된 코드

- 주석으로 처리된 코드는 얼마나 오래된 코드인지 중요한 코드인지 알 길이 없다.
- 코드는 그 자리에 남아 매일매일 낡아간다.
- 주석으로 처리된 코드를 발견하면 즉각 지워버려라. 소스 코드 관리 시스템이 기억한다.

# 환경

---

## E1: 여러 단계로 빌드해야 한다.

- 빌드는 한 단계로 끝내야 한다.
- JAR 파일, XML 파일, 기타 시스템에 필요한 파일을 찾느라 뒤적일 필요가 없어야 한다.
- 한 명령으로 전체를 체크아웃해서 빌드할 수 있어야 한다.

```java
svn get mySystem
cd mySystem
ant all
```

## E2: 여러 단계로 테스트해야 한다.

- 모든 단위 테스트는 한 명령으로 돌려야 한다.
- 아무리 열악한 환경이라도 셸에서 명령 하나로 가능해야 한다.
- 모든 테스트를 한 번에 실행하는 능력은 근본적이고 중요하다. 그 방법이 빠르고 쉽고 명백해야 한다.

# 함수

---

## F1: 너무 많은 인수

- 함수에서 인수는 작을수록 좋다. 아예 없으면 가장 좋다.
- 그 다음으로 하나, 둘, 셋이 차례로 좋다.
- 넷 이상은 가치가 의심스러우므로 최대한 피한다.

## F2: 출력 인수

- 출력 인수는 직관을 정면으로 위배한다.
- 일반적으로 개발자는 인수를 출력이 아닌 입력으로 간주한다.
- 함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

## F3: 플래그 인수

- `boolean` 인수는 함수가 여러 기능을 수행한다는 명백한 증거다.
- 플래그 인수는 혼란을 초래하므로 피해야 마땅하다.

## F4: 죽은 함수

- 아무도 호출하지 않는 함수는 삭제한다.
- 죽은 코드는 낭비다. 과감히 삭제하라.

# 일반

- 한 소스 파일에 여러 언어를 사용한다
- 당연한 동작을 구현하지 않는다
- 경계를 올바로 처리하지 않는다
- 안전 절차 무시
- 중복
- 추상화 수준이 올바르지 못하다
- 기초 클래스가 파생 클래스에 의존한다
- 과도한 정보
- 죽은 코드
- 수직 분리
- 일관성 부족
- 잡동사니
- 인위적 결합
- 기능 욕심
- 선택자 인수
- 모호한 의도
- 잘못 지운 책임
- 부적절한 static 함수
- 서술적 변수
- 이름과 기능이 일치하는 함수
- 알고리즘을 이해하라
- 논리적 의존성은 물리적으로 드러내라
- If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
- 표준 표기법을 따르다
- 매직 숫자는 명명된 상수로 교체하라
- 정확하라
- 관례보다 구조를 사용하라
- 조건을 캡슐화하라
- 부정 조건은 피하라
- 함수는 한 가지만 해야 한다
- 경제 조건을 캡슐화하라
- 함수는 추상화 수준을 한 단계만 내려가야 한다
- 설정 정보는 최상위 단계에 둬라
- 추이적 탐색을 피해라

# 자바

---

## J1: 긴 import 목록을 피하고 와일드카드를 사용하라

- 긴 import 문은 읽기 부담스럽다.
- 명시적인 import문은 강한 의존성을 생성하지만 와일드카드는 그렇지 않다.
- 와일드카드 import 문은 때로 이름 충돌이나 모호성을 초래한다.
- 이름이 같으나 패키지가 다른 클래스는 명시적인 import 문을 사용하거나 코드에서 클래스를 사용할 때 전체 경로를 명시한다.
    - 다소 번거럽지만 자주 발생하지 않으므로 와일드카드 import 문이 명시적인 import 문보다 좋다.

## J2: 상수는 상속하지 않는다

- 상수를 인터페이스에 넣고 해당 상수를 상속하는 경우가 있다.
    - 언어의 범위 규칙을 속이는 행위다.

## J3: 상수 대 Enum

- 자바 5부터 eunm을 제공한다.
- public static final int라는 옛날 기교를 사용할 필요가 없다.
- enum은 이름이 부여된 열거체(enumeration)에 속한다.

# 이름

## N1: 서술적인 이름을 사용하라

- 이름은 성급하게 정하지 않는다.
- 서술적인 이름을 신중하게 고른다.
- 이름을 적절히 지었다면 코드를 금방 이해한다.
- 신중하게 선택한 이름은 추가 설명을 포함한 코드보다 강력하다.

## N2: 적절한 추상화 수준에서 이름을 선택하라

- 구현을 드러내는 이름을 피하라.
- 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라

```java
public interface Modem {
	boolean dial(String phoneNumber);
	boolean disconnect();
	boolean send(char c);
	char recv();
	String getConnectedPhoneNumber();
}
```

- 여기서 전화번호라는 개념은 전화선에 연결하는 모뎀의 구현을 한정짓는다.
- USB로 연결된 스위치에 포트 번호를 보내는 모뎀도 있다. 따라서 추상화 수준이 틀렸다.

```java
public interface Modem {
	boolean connect(String connectionLocator);
	boolean disconnect();
	boolean send(char c);
	char recv();
	String getConnectedLocator();
}
```

## N3: 가능하다면 표준 명명법을 사용하라

- 기존 명명법을 사용하는 이름은 이해하기 더 쉽다.
- 패턴은 한 가지 표준에 불과하다. Decorator 패턴을 사용한다면 클래스 이름 끝에 -Decorator를 붙이는 것이 적합하다.
- 에릭 에반스(Eric Evans)는 이를 프로젝트의 유비쿼터스 언어(ubiquitous language)라 부른다.

## N4: 명확한 이름

- 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.

## N5: 긴 범위는 긴 이름을 사용하라

- 이름 길이는 범위 길이에 비례해야 한다.
- 범위가 작으면 아주 짧은 이름을 사용해도 괜찮다.
- 여기서 말하는 범위는 코드의 라인수이다.

```java
private void rollMany(int n, int pins) {
	for (int i = 0; i < n; i++) {
		g.roll(pins);
	}
}
```

- 변수 `i`를 `rollCount`로 이름을 지었으면 오히려 헷갈렸을 것이다.

## N6: 인코딩을 피하라

- 이름에 유형 정보나 범위 정보를 넣어서는 안된다.
- 헝가리안 표기법의 오염에서 이름을 보호하라.

## N7: 이름으로 부수 효과를 설명하라

- 이름에 부수효과를 숨기지 않는다.
- 함수, 변수, 클래스가 하는 일을 모두 기술해라.
- 여러 작업을 수행하는 함수에다 동사 하나만 달랑 사용하면 곤란하다.

```java
public ObjectOutputStream getOos() throws IOException {
	if (m_oos == null) {
		m_oos = new ObjectOutputStream(m_socket.getOutputStream());
	}
	return m_oos;
}
```

- 위 함수는 단순히 “oos”만 가져오지 않는다. 기존에 “oos”가 없으면 생성한다.
- 그러므로 `createOrReturnOos`라는 이름이 더 좋다.

# 테스트

---

## T1: 불충분한 테스트

- 테스트 케이스는 잠재적으로 깨질만한 부분을 모두 테스트해야 한다.
- 테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.

## T2: 커버리지 도구를 사용하라!

- 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다.
- 커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다.
- 대다수 IDE는 테스트 커버리지를 시각적으로 표현한다.

## T3: 사소한 테스트를 건너뛰지 마라

- 사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다.

## T4: 무시한 테스트는 모호함을 뜻한다

- 때로는 요구사항이 불분명하기에 프로그램이 돌아가는 방식을 확신하기 어렵다.
- 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 `@Ignore`, `@Disable`를 붙여 표현한다.
- 선택 기준은 모호함이 존재하는 테스트 케이스가 컴파일이 가능한지 불가능한지에 달려있다.

## T5: 경계조건을 테스트하라

- 알고리즘의 중앙 조건은 올바르게 짜놓고 경계 조건에서 실수하는 경우가 흔하다.

## T6: 버그 주변은 철저히 테스트하라

- 버그는 서로 모이는 경향이 있다.
- 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다.

## T7: 실패 패턴을 살펴라

- 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다.
- 합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다.

## T8: 테스트 커버리지  패턴을 살펴라

- 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.

## T9: 테스트는 빨라야 한다

- 느린 테스트 케이스는 실행하지 않게 된다.
- 일정이 촉박해지면 느린 테스트 케이스를 제일 먼저 건너뛴다.

# 결론

- 이 가치 체계는 책의 주체이자 목표이다.
- 가치에 기반한 규율과 절제가 필요하다.
